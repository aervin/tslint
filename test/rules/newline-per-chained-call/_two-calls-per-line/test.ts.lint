SomeClass
    .propA
    .propB
    .helloYay(function() {
        return 1;
    }).test();

SomeClass
    .propA
    .propB
    .helloYay(function() {
        return 1;
    }).  test();

SomeClass.propA.propB.methodB(() => {
    return "hello Yay!";
}).helloYay((a: number) => {
    return a + 1;
}).helloYayB((a: number) => {
    return a + 1;
});

SomeClass.propA.propB.methodB(() => {
    return "hello Yay!";
}).uhOh().helloYay((a: number) => {
         ~~~~~~~~~ [ERROR]
    return a + 1;
}).helloYayB((a: number) => {
    return a + 1;
});

this.getFoo()[0].toString();

this.foo()["bar"]().buzz();
                   ~~~~~ [ERROR]

this.foo()["bar"]();

foo().bar();

const y: string[] = _observable
                        .map(function(item) { return item.helloYay().another() }
                        .operator()    
                        .another(function(result) { return result.hello.Yay! }).wrong();

SomeClass.propA.helloYay((a: number) => {
    return a + 1;
});

this.some.nested();

const y: string[] = _observable
                        .map(function(item) { return item.helloYay! })
                        .operator()    
                        .another(function(result) { return result.hello.Yay! });


const y: string[] = _observable.map(item => item.helloYay).operator().another(function(result) { return result.helloYay! });
                                                                     ~~~~~~~~ [ERROR]

const x: string[] = _observable.map(item => item.helloYay);

SomeClass.propA.propB.helloYay();

SomeClass
    .propA
    .propB
    .helloYay();

SomeClass
    .propA
    .propB.helloYay();

SomeClass
    .propA
    .propB
    .helloYay(function() {
        return 1;
    }).
    test();

SomeClass.propA.propB.methodB(() => {
    return "hello Yay!";
})
.helloYay((a: number) => {
    return a + 1;
});

SomeClass.propA.propB.methodB(() => {
    return "hello Yay!";
})
.helloYay((a: number) => {
    return obj.method()
                .chainedButOkay(
                    objB.nested().superNestedCall()
                )
});

SomeClass.propA.propB.methodB(() => {
    return "hello Yay!";
})
.helloYay((a: number) => {
    return obj.method()
                .chainedButOkay(
                    objB.nested()
                        .superNestedCall()
                )
});

const mySpy = jasmine.createSpy()
    .and.returnValue(true);

const mySpy = jasmine.createSpy()
    [4].returnValue(true);

SomeClass
    .propA
    .propB
    .methodC(() => {
        return "hello Yay!";
    })
    .helloYay(() => {
        return 1;
    });

[ERROR]: When chaining calls, put method calls on new lines.