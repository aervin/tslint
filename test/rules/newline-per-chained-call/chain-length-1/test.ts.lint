some().prop
    .method()
    .call();

SomeClass.propA.helloMom((a: number) => {
~~~~~~~~~~~~~~~~~~~~~~~~ [ERROR]
    return a + 1;
});

this.some(); // Should not count 'this' as part of the chain.

this.some.deeply.nested();

const y: string[] = _observable
                        .map(function(item) { return item.helloMom! })
                        .operator()
                        .another(function(result) { return result.helloMom! });

const y: string[] = _observable
                        .map(function(item) {
                            return item
                                    .helloMom! 
                        })
                        .operator()
                        .another(function(result) { return result.helloMom! });

const y: string[] = _observable.map(item => item.helloMom).operator().another(function(result) { return result.helloMom! });

const x: string[] = _observable.map(item => item.helloMom);
                    ~~~~~~~~~~~~~~~ [ERROR]

SomeClass.propA.propB.helloMom();

SomeClass
    .propA
    .propB
    .helloMom();

SomeClass
    .propA
    .propB
    .helloMom(function() {
        return 1;
    });

SomeClass.propA.propB.methodB(() => {
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    return "hello mom!";
~~~~~~~~~~~~~~~~~~~~~~~~
}).helloMom((a: number) => {
~~~~~~~~~~~ [ERROR]
    return a + 1;
});

SomeClass
    .propA
    .propB
    .methodC(() => {
        return "hello mom!";
    })
    .helloMom(() => {
        return 1;
    });

[ERROR]: Chained accessors should span multiple lines.