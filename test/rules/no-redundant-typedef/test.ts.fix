let myVerboseArrow: () => number = () => 5;

let myVerboseArrow: (a: string) => number = (a) => 5;

let myVerboseSignature: (a: number) => number = function myVerboseSignature(a) {
    return a;
};

let myVerboseSignature: (a: number) => number = function(a) {
    return a;
};

let myVerboseSignature: (a: number) => number = function myVerboseSignature(a) {
    return a;
};

let myVerboseSignature: (a) => number = function myVerboseSignature(a: number) {
    return a;
};

const cb: (node: ts.Node) => void = (node) => {
    let myVerboseSignature: (a: number) => number = function myVerboseSignature(a) {
        return a;
    };
    if (isVariableDeclaration(node) && node.type !== undefined) {
        if (declarationHasRedundantTypedef(node)) {
            this.addFailureAtNode(node.name, Rule.FAILURE_STRING);
        }
    }
    return ts.forEachChild(node, cb);
};

const cb: (node:ts.Node) => void = (node) => {
    if (isVariableDeclaration(node) && node.type !== undefined) {
        if (declarationHasRedundantTypedef(node)) {
            this.addFailureAtNode(node.name, Rule.FAILURE_STRING);
        }
    }
    return ts.forEachChild(node, cb);
};

let a: (b: string) => string = function mySignature(b) { return b + "!"; };

let a = function mySignature(b: string): string { return b + "!"; };

const cb: (node:ts.Node) => void = (node) => {
    if (isVariableDeclaration(node) && node.type !== undefined) {
        if (declarationHasRedundantTypedef(node)) {
            this.addFailureAtNode(node.name, Rule.FAILURE_STRING);
        }
    }
    return ts.forEachChild(node, cb);
};
